## 前言

这是项目私信系统的websocket的相关说明：

理清概念：

🏷️ 在websocket里面，前端可以和后台互相沟通交流，这里将前端发给后台的消息包称为request包

后台发给前端的包称为response包；

🏷️ websockt的大致流程为：建立连接—>发送消息->接收消息。。。。到最后前端直接关闭连接即为结束。



## 建立连接

URL: 120.77.242.172:8080/teaching/imserver/{userId} 其中userId为用户ID

 ⚠️ 注意 这里之后会将userID换成jwt的token 待实验这样是否可行

🏷️ 原因：因为目前有隐患，如果随意一个人使用一个假的userID随意可以伪装为ID为xx的人和后台进行交互，极不安全，等前端搭建完私信系统之后，后台再进行考虑和修改。

## 发送消息

消息request的格式如下：

```json
{
  "fromId": 1, //发送消息的用户ID
  "toId": 2, //接受消息的用户ID 
  "type": 0, // 消息类型 其中 发送私信的type为0 确认消息已读的type为1;
  "content": "你好", //消息的文本内容
  "timestamp": "1589790567", //时间戳，需要前端构建
  "Describe": "" //扩展字段，针对不同类型的包进行而外扩展，在此处为空
}
```

向连接发送消息后，若消息后台接收成功，则会返回response包

```json
{
  "fromId": 0, //消息来自哪个用户 系统ID为0 
  "toId": 1, //接收这个消息的用户ID
  "type": 0, // response的type类型，有三种。其中0位响应成功包，用于向发送私信的用户发送成功的提示；1位响应失败包，暂时用不上；2为消息包，即收到了来自其他用户的私信
  "content": "", //私信（消息）的文本内容，此处会为空
  "timestamp": "1589790567", //时间戳，用来前端区分私信顺序
  "Describe": "" // 扩展字段
}
```

 ⚠️ 注意，若前端在发完消息的6秒（暂定为6秒）内没有收到上述的response包时，说明消息发送失败，此时可以重试3次，三次失败提醒用户发送失败。

效果如下：

![发送消息效果](https://raw.githubusercontent.com/carrymaniac/pic/master/20200518200150.png)

当收到该包时，说明消息发送成功，此时可以将用户发送的消息显示在界面上。



## 接收消息

当用户接收到别人发来的私信的时候，response包格式如下：

```json

{
  "fromId": 1, //消息来自哪个用户 此处表示ID为1的用户发来了消息
  "toId": 2, //接收这个消息的用户ID
  "type": 2, // response的type类型，有三种。其中0位响应成功包，用于向发送私信的用户发送成功的提示；1位响应失败包，暂时用不上；2为消息包，即收到了来自其他用户的私信
  "content": "你好", //私信（消息）的文本内容
  "timestamp": "1589790567", //时间戳，用来前端区分私信顺序
  "Describe": "form" // 扩展字段，扩展字段会以普通的JSON字符串存储，需要前端取出并转换。在此情况会有三个扩展字段为：
  {
  "userName":"小明" //私信发送者的名字
  "headURL":"www.baidu.com" //私信发送者的头像
  "messageId":"2323" //私信的ID
	}
}
```

前端显示该条消息

 ⚠️ 注意，当用户（72）看到71发来的该条消息之后，前端需要向后台发送一个确认包，以确认消息已经成功被用户阅读，此时包格式如下:

```json
{
  "fromId": 1, //发送消息的用户ID
  "toId": 0, //接受消息的用户ID 0即系统
  "type": 1, // 消息类型 其中 发送私信的type为0 确认消息已读的type为1;
  "content": "[12,13,14]", //需要确认已读的消息ID ，以Array的形式存储为字符串 放在content中
  "timestamp": "1589790567", //时间戳，需要前端构建
  "Describe": "" //扩展字段，针对不同类型的包进行而外扩展，在此处为空
}
```

此确认request不会有response来响应发送成功，因此静默发送即可。









A  -> server 

B -> server



A -> B

